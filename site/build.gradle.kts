import com.varabyte.kobweb.gradle.application.util.configAsKobwebApplication
import kizzy.tailwind.utils.setupTailwindProject
import java.time.ZonedDateTime
import java.time.format.DateTimeFormatter
import ImageProcessor

buildscript {
    dependencies {
        classpath("org.yaml:snakeyaml:2.0")
    }
}

plugins {
    alias(libs.plugins.kotlin.multiplatform)
    alias(libs.plugins.compose.compiler)
    alias(libs.plugins.kobweb.application)
    alias(libs.plugins.kobwebx.markdown)
    alias(libs.plugins.kotlin.serialization)
    id("io.github.dead8309.tailwind-kt").version("0.0.4")
}

group = "com.shevapro.website"
version = "1.0-SNAPSHOT"

// Markdown processing functions
fun generateArticleDescriptors(publishedEntries: List<Any>): List<String> {
    return publishedEntries.map { entry ->
        val entryClass = entry.javaClass
        val getFilePath = entryClass.getMethod("getFilePath")
        val getRoute = entryClass.getMethod("getRoute")
        val getFrontMatter = entryClass.getMethod("getFrontMatter")

        val filePath = getFilePath.invoke(entry) as String
        val route = getRoute.invoke(entry) as String
        val frontMatter = getFrontMatter.invoke(entry)

        val relPath = filePath.substringAfter("resources/public/content/")

        // Access frontMatter properties using array access syntax
        val frontMatterClass = frontMatter.javaClass
        val getMethod = frontMatterClass.getMethod("get", String::class.java)

        val titleValue = (getMethod.invoke(frontMatter, "title") as? List<*>)?.firstOrNull()?.toString()
        val descValue = (getMethod.invoke(frontMatter, "description") as? List<*>)?.firstOrNull()?.toString()
        val dateValue = (getMethod.invoke(frontMatter, "date") as? List<*>)?.firstOrNull()?.toString()
        val thumbValue = (getMethod.invoke(frontMatter, "thumbnailUrl") as? List<*>)?.firstOrNull()?.toString()
        val tagsValue = (getMethod.invoke(frontMatter, "tags") as? List<*>)?.joinToString(", ") { "\"$it\"" } ?: ""

        val titleStr = if (titleValue != null) "\"$titleValue\"" else "null"
        val descStr = if (descValue != null) "\"$descValue\"" else "null"
        val dateStr = if (dateValue != null) "\"$dateValue\"" else "null"
        val thumbStr = if (thumbValue != null) "\"$thumbValue\"" else "null"

        """ArticleDescriptor(
    route = "$route",
    filePath = "/content/${relPath.replace("\\", "/")}",
    title = $titleStr,
    description = $descStr,
    date = $dateStr,
    tags = listOf($tagsValue),
    thumbnail = $thumbStr
)"""
    }
}

fun getMarkdownArticlesTemplate(): String {
    return """
package com.shevapro.website.utils

import com.shevapro.website.models.Article

/**
 * IMPORTANT: Automated Markdown Article System
 * 
 * The build system automatically processes markdown files from:
 * - src/jsMain/resources/public/content/blog/
 * - src/jsMain/resources/public/content/portfolio/
 * 
 * It generates this file (MarkdownArticles.kt) with article metadata during the build process.
 * 
 * Current Implementation:
 * - This file is automatically generated during the build process
 * - It contains a list of all articles found in the markdown directories
 * - The functions getBlogArticles() and getPortfolioArticles() filter this list
 * - This approach ensures that the code compiles and works correctly
 * 
 * To add a new article:
 * 1. Add a new markdown file to the appropriate directory
 * 2. Build the project to regenerate this file with the updated article list
 * 
 * The system is now fully automated - no need to manually update article lists!
 */
data class ArticleDescriptor(
    val route: String,
    val filePath: String,
    val title: String?,
    val description: String?,
    val date: String?,
    val tags: List<String>,
    val thumbnail: String?
)

// Auto-generated list of articles from markdown files
private val markdownIndex = listOf(
    // ARTICLE_DESCRIPTORS_PLACEHOLDER
)

fun ArticleDescriptor.toArticle(): Article {
    val slug = route.substringAfterLast("/")

    return Article(
        id = slug,
        slug = slug,
        title = title ?: "Untitled",
        content = "", // Content will be loaded separately when needed
        description = description ?: "",
        author = "Shevapro",
        dateAdded = date ?: "",
        tags = tags,
        imageUrl = if (thumbnail != null) "/assets/images/${'$'}thumbnail" else "/favicon.ico",
    )
}

/**
 * Returns a list of articles from a specific category.
 *
 * @param category The category to filter articles by (e.g., "blog", "portfolio", "design")
 * @return List of Article objects from the specified category
 */
fun getArticles(category: String): List<Article> {
    return markdownIndex
        .filter { it.route.startsWith("/${'$'}category") }
        .map { it.toArticle() }
}
""".trimIndent()
}

fun generateMarkdownKotlinFiles(
    project: org.gradle.api.Project,
    descriptorBlocks: List<String>
) {
    val genDir = project.layout.buildDirectory.asFile.get().resolve("generated/kobweb/markdown")
    genDir.mkdirs()

    val srcDir = project.layout.projectDirectory.asFile.resolve("src/jsMain/kotlin/com/shevapro/website/utils")

    // Generate MarkdownIndex.kt (for backward compatibility)
    val indexContent = """
// AUTO-GENERATED ‚Äì DO NOT EDIT
package com.shevapro.website.generated

data class ArticleDescriptor(
    val route: String,
    val filePath: String,
    val title: String?,
    val description: String?,
    val date: String?,
    val tags: List<String>,
    val thumbnail: String?
)

val MarkdownIndex: List<ArticleDescriptor> = listOf(
    ${descriptorBlocks.joinToString(",\n")}
)
""".trimIndent()

    genDir.resolve("MarkdownIndex.kt").writeText(indexContent)

    // Generate MarkdownArticles.kt
    val markdownArticlesContent = getMarkdownArticlesTemplate().replace(
        "// ARTICLE_DESCRIPTORS_PLACEHOLDER",
        descriptorBlocks.joinToString(",\n    ")
    )

    srcDir.resolve("MarkdownArticles.kt").writeText(markdownArticlesContent)
}

fun updateSitemap(project: org.gradle.api.Project, publishedEntries: List<Any>) {
    val sitemapFile = project.layout.projectDirectory.file("src/jsMain/resources/public/sitemap.xml").asFile
    val currentTimestamp = ZonedDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss'Z'"))

    if (!sitemapFile.exists()) {
        println("‚ö†Ô∏è Sitemap file does not exist at ${sitemapFile.absolutePath}")
        return
    }

    println("üìÑ Updating sitemap.xml with ${publishedEntries.size} markdown entries...")

    val existingSitemap = sitemapFile.readText()
    val closingTagIndex = existingSitemap.lastIndexOf("</urlset>")

    if (closingTagIndex == -1) {
        println("‚ö†Ô∏è Could not find closing </urlset> tag in existing sitemap")
        return
    }

    val baseSitemap = existingSitemap.substring(0, closingTagIndex).trim()

    // Extract current blog/portfolio URLs for comparison
    val existingBlogUrls = Regex("<loc>https://www\\.shevapro\\.com/blog/[^<]+</loc>")
        .findAll(existingSitemap)
        .map { it.groupValues[0] }
        .toSet()

    val existingPortfolioUrls = Regex("<loc>https://www\\.shevapro\\.com/portfolio/[^<]+</loc>")
        .findAll(existingSitemap)
        .map { it.groupValues[0] }
        .toSet()

    // Remove existing blog/portfolio sections completely to rebuild them
    val cleanedSitemap = baseSitemap
        .replace(
            Regex(
                "\\s*<!-- Blog Posts -->.*?(?=\\s*<url>|\\s*<!-- Portfolio Items -->|$)",
                RegexOption.DOT_MATCHES_ALL
            ), ""
        )
        .replace(Regex("\\s*<!-- Portfolio Items -->.*?(?=\\s*<url>|$)", RegexOption.DOT_MATCHES_ALL), "")
        .replace(
            Regex("\\s*<url>\\s*<loc>https://www\\.shevapro\\.com/blog/.*?</url>", RegexOption.DOT_MATCHES_ALL),
            ""
        )
        .replace(
            Regex(
                "\\s*<url>\\s*<loc>https://www\\.shevapro\\.com/portfolio/.*?</url>",
                RegexOption.DOT_MATCHES_ALL
            ), ""
        )

    // Update timestamps in remaining URLs (static pages)
    val updatedBaseSitemap = cleanedSitemap.replace(
        Regex("<lastmod>.*?</lastmod>"),
        "<lastmod>$currentTimestamp</lastmod>"
    )

    val sitemapBuilder = StringBuilder(updatedBaseSitemap)

    // Process blog entries
    val blogEntries = publishedEntries.filter { entry ->
        val entryClass = entry.javaClass
        val getRoute = entryClass.getMethod("getRoute")
        val route = getRoute.invoke(entry) as String
        route.startsWith("/blog")
    }

    val newBlogUrls = mutableSetOf<String>()
    if (blogEntries.isNotEmpty()) {
        sitemapBuilder.append("\n    <!-- Blog Posts -->")
        blogEntries.forEach { entry ->
            val entryClass = entry.javaClass
            val getRoute = entryClass.getMethod("getRoute")
            val route = getRoute.invoke(entry) as String
            val url = "https://www.shevapro.com$route"
            newBlogUrls.add("<loc>$url</loc>")
            sitemapBuilder.append(
                """
    <url>
        <loc>$url</loc>
        <changefreq>yearly</changefreq>
        <lastmod>$currentTimestamp</lastmod>
    </url>"""
            )
        }
    }

    // Process portfolio entries
    val portfolioEntries = publishedEntries.filter { entry ->
        val entryClass = entry.javaClass
        val getRoute = entryClass.getMethod("getRoute")
        val route = getRoute.invoke(entry) as String
        route.startsWith("/portfolio")
    }

    val newPortfolioUrls = mutableSetOf<String>()
    if (portfolioEntries.isNotEmpty()) {
        sitemapBuilder.append("\n    <!-- Portfolio Items -->")
        portfolioEntries.forEach { entry ->
            val entryClass = entry.javaClass
            val getRoute = entryClass.getMethod("getRoute")
            val route = getRoute.invoke(entry) as String
            val url = "https://www.shevapro.com$route"
            newPortfolioUrls.add("<loc>$url</loc>")
            sitemapBuilder.append(
                """
    <url>
        <loc>$url</loc>
        <changefreq>yearly</changefreq>
        <lastmod>$currentTimestamp</lastmod>
    </url>"""
            )
        }
    }

    sitemapBuilder.append("\n</urlset>")
    sitemapFile.writeText(sitemapBuilder.toString())

    // Log changes for transparency
    val removedBlogUrls = existingBlogUrls - newBlogUrls
    val addedBlogUrls = newBlogUrls - existingBlogUrls
    val removedPortfolioUrls = existingPortfolioUrls - newPortfolioUrls
    val addedPortfolioUrls = newPortfolioUrls - existingPortfolioUrls

    val totalUrls = sitemapBuilder.toString().split("<url>").size - 1
    println("‚úÖ Sitemap updated successfully:")
    println("   üìù Blog posts: ${blogEntries.size} (${addedBlogUrls.size} added, ${removedBlogUrls.size} removed)")
    println("   üíº Portfolio items: ${portfolioEntries.size} (${addedPortfolioUrls.size} added, ${removedPortfolioUrls.size} removed)")
    println("   üîó Total URLs: $totalUrls")
    println("   üïê Timestamp: $currentTimestamp")

    if (removedBlogUrls.isNotEmpty()) {
        println("   üóëÔ∏è Removed blog URLs: ${removedBlogUrls.joinToString(", ")}")
    }
    if (removedPortfolioUrls.isNotEmpty()) {
        println("   üóëÔ∏è Removed portfolio URLs: ${removedPortfolioUrls.joinToString(", ")}")
    }
}

kobweb {
    app {
        index {
            // Set site-wide description for SEO
            description.set("Shevapro's personal website showcasing portfolio, blog, and services")
            
            // Note: Other site-wide SEO metadata is handled in the Layout component
            // through the setPageMetadata function

        }
    }
    markdown {
        // Tell Kobweb to look for markdown files in the content directory (for metadata only)
        addSource(project.layout.projectDirectory.dir("src/jsMain/resources/public/content"))

        /**
         * 1. Files are in `src/jsMain/resources/public/content/...` for runtime HTTP access
         * 2. Generate a Kotlin source file (`MarkdownIndex.kt`) that lists metadata for all posts.
         * 3. We'll handle rendering ourselves in EnhancedMarkdownLayout using unified processor
         */
        process.set { entries ->
            // Filter out unpublished entries at the very beginning
            val publishedEntries = entries.filter { entry ->
                val getFrontMatter = entry.javaClass.getMethod("getFrontMatter")
                val frontMatter = getFrontMatter.invoke(entry)
                val frontMatterClass = frontMatter.javaClass
                val getMethod = frontMatterClass.getMethod("get", String::class.java)
                val postedValue =
                    (getMethod.invoke(frontMatter, "posted") as? List<*>)?.firstOrNull()?.toString()?.toBoolean()
                        ?: true
                postedValue
            }

            println("üìÑ Processing markdown files:")
            println("   üìù Total found: ${entries.size}")
            println("   ‚úÖ Published: ${publishedEntries.size}")
            println("   üö´ Unpublished (skipped): ${entries.size - publishedEntries.size}")

            // Generate article descriptors
            val descriptorBlocks = generateArticleDescriptors(publishedEntries)

            // Generate markdown files
            generateMarkdownKotlinFiles(project, descriptorBlocks)

            // Update sitemap
            updateSitemap(project, publishedEntries)
        }
    }
}

// Make kobweb tasks depend on sitemap generation
//tasks.named("kobwebStart").configure {
//    // dependsOn("kobwebxMarkdownProcess") // TODO: Determine correct task name
//}

// Make jsProcessResources depend on processImages
tasks.named("kobwebxMarkdownProcess").configure {
    dependsOn("processImages")
}
tasks.named("kobwebExport").configure {
    // Remove dependency for now until we determine the correct task name
    // dependsOn("kobwebxMarkdownProcess") // TODO: Determine correct task name
    dependsOn("processImages") // Generate mobile images before export
    finalizedBy("copy404")
}

// Image processing task
tasks.register("processImages") {
    group = "build setup"
    description = "Generate mobile versions of images with -m suffix"
    
    // Make task incremental - only run if images have changed
    inputs.dir(project.layout.projectDirectory.dir("src/jsMain/resources/public/assets/images"))
    outputs.dir(project.layout.projectDirectory.dir("src/jsMain/resources/public/assets/images"))
    
    doLast {
        val imagesDir = project.layout.projectDirectory.dir("src/jsMain/resources/public/assets/images").asFile
        
        // Configure crop settings
        val config = ImageProcessor.CropConfig(
            maxWidth = 800,     // Max width for mobile (anything above is desktop)
            maxHeight = 800,    // Max height for mobile (allow portrait images)
            suffix = "-m",      // Mobile suffix
            generateWebP = false // Disable WebP for now until library loads properly
        )

        ImageProcessor. processImages(imagesDir, config)

        println("‚úÖ Image processing completed!")
    }
}

// Force image processing for development
tasks.register("processImagesForce") {
    group = "build setup"
    description = "Force regenerate mobile versions of all images"

    doLast {
        val imagesDir = project.layout.projectDirectory.dir("src/jsMain/resources/public/assets/images").asFile

        // Delete all existing mobile versions first
        imagesDir.walkTopDown()
            .filter { it.isFile && it.name.contains("-m.") }
            .forEach {
                println("üóëÔ∏è Deleting existing mobile version: ${it.name}")
                it.delete()
            }

        // Configure crop settings
        val config = ImageProcessor.CropConfig(
            maxWidth = 800,     // Max width for mobile (anything above is desktop)
            maxHeight = 800,    // Max height for mobile (allow portrait images)
            suffix = "-m"       // Mobile suffix
        )
        
        ImageProcessor.processImages(imagesDir, config)
        
        println("‚úÖ Force image processing completed!")
    }
}

tasks.register<Copy>("copy404") {
    // Adjust the path if your export location is different
    from("$rootDir/site/.kobweb/site/not-found.html")
    into("$rootDir/site/.kobweb/site")
    rename("not-found.html", "404.html")
    println("404.html has been copied successfully.")
}

kotlin {
    configAsKobwebApplication("website")
    setupTailwindProject()

    sourceSets {
        jsMain.dependencies {
            implementation(libs.compose.runtime)
            implementation(libs.compose.html.core)
            implementation(libs.kobweb.core)
            implementation(libs.kobweb.silk)
            implementation(libs.silk.icons.fa)
            implementation(libs.kobwebx.markdown)
            implementation(libs.kotlinx.serialization.json)

            implementation(npm("unified", "11.0.4"))
            implementation(npm("remark-parse", "11.0.0"))
            implementation(npm("remark-gfm", "4.0.0"))
            implementation(npm("remark-math", "6.0.0"))
            implementation(npm("remark-rehype", "11.1.0"))
            implementation(npm("rehype-katex", "7.0.0"))
            implementation(npm("rehype-raw", "7.0.0"))
            implementation(npm("rehype-stringify", "9.0.4"))

            implementation(project(":worker"))
        }
    }
    // Add generated markdown source directory to jsMain
    sourceSets["jsMain"].kotlin.srcDir(layout.buildDirectory.asFile.get().resolve("generated/kobweb/markdown"))
}
