import com.varabyte.kobweb.gradle.application.util.configAsKobwebApplication
import kizzy.tailwind.utils.setupTailwindProject
import java.time.ZonedDateTime
import java.time.format.DateTimeFormatter

buildscript {
    dependencies {
        classpath("org.yaml:snakeyaml:2.0")
    }
}

plugins {
    alias(libs.plugins.kotlin.multiplatform)
    alias(libs.plugins.compose.compiler)
    alias(libs.plugins.kobweb.application)
    alias(libs.plugins.kobwebx.markdown)
    alias(libs.plugins.kotlin.serialization)
    id("io.github.dead8309.tailwind-kt").version("0.0.4")
}

group = "com.shevapro.website"
version = "1.0-SNAPSHOT"

kobweb {
    app {
        index {
//            description.set("Made with ‚ù§ by Shevapro")
        }
    }
    markdown {
        // Tell Kobweb to look for markdown files in the public directory
        addSource(project.layout.projectDirectory.dir("src/jsMain/resources/public/markdown"))

        /**
         * 1. Files are already in `src/jsMain/resources/public/markdown/...` for runtime HTTP access
         * 2. Generate a Kotlin source file (`MarkdownIndex.kt`) that lists metadata for all posts.
         */
        process.set { entries ->
            // Filter out unpublished entries at the very beginning
            val publishedEntries = entries.filter { entry ->
                val isPosted = entry.frontMatter["posted"]?.firstOrNull()?.toBoolean() ?: true
                isPosted
            }

            println("üìÑ Processing markdown files:")
            println("   üìù Total found: ${entries.size}")
            println("   ‚úÖ Published: ${publishedEntries.size}")
            println("   üö´ Unpublished (skipped): ${entries.size - publishedEntries.size}")

            val genDir = project.layout.buildDirectory.asFile.get().resolve("generated/kobweb/markdown")
            genDir.mkdirs()

            // 2. Prepare to generate MarkdownArticles.kt in source directory
            val srcDir = project.layout.projectDirectory.asFile.resolve("src/jsMain/kotlin/com/shevapro/website/utils")
            
            // Template for MarkdownArticles.kt
            val templateContent = """
            package com.shevapro.website.utils

            import com.shevapro.website.models.Article

            /**
             * IMPORTANT: Automated Markdown Article System
             * 
             * The build system automatically processes markdown files from:
             * - src/jsMain/resources/public/markdown/blog/
             * - src/jsMain/resources/public/markdown/portfolio/
             * 
             * It generates this file (MarkdownArticles.kt) with article metadata during the build process.
             * 
             * Current Implementation:
             * - This file is automatically generated during the build process
             * - It contains a list of all articles found in the markdown directories
             * - The functions getBlogArticles() and getPortfolioArticles() filter this list
             * - This approach ensures that the code compiles and works correctly
             * 
             * To add a new article:
             * 1. Add a new markdown file to the appropriate directory
             * 2. Build the project to regenerate this file with the updated article list
             * 
             * The system is now fully automated - no need to manually update article lists!
             */
            data class ArticleDescriptor(
                val route: String,
                val filePath: String,
                val title: String?,
                val description: String?,
                val date: String?,
                val tags: List<String>,
                val thumbnail: String?
            )

            // Auto-generated list of articles from markdown files
            private val markdownIndex = listOf(
                // ARTICLE_DESCRIPTORS_PLACEHOLDER
            )

            fun ArticleDescriptor.toArticle(): Article {
                val slug = route.substringAfterLast("/")
                val isPortfolioArticle = route.startsWith("/portfolio")

                return Article(
                    id = slug,
                    slug = slug,
                    title = title ?: "Untitled",
                    content = "", // Content will be loaded separately when needed
                    description = description ?: "",
                    author = "Shevapro",
                    dateAdded = date ?: "",
                    tags = tags,
                    imageUrl = if (thumbnail != null) "/assets/images/${'$'}thumbnail" else "/favicon.ico",
                    isPortfolioArticle = isPortfolioArticle,
                    posted = true // All entries in the index are published
                )
            }

            /**
             * Returns a list of blog articles.
             * 
             * This function filters the auto-generated markdownIndex list for articles with routes
             * that start with "/blog" and are posted, then converts them to Article objects.
             * 
             * The list is automatically updated when new markdown files are added to the blog directory.
             */
            fun getBlogArticles(): List<Article> {
                // Use the auto-generated markdownIndex list to get posted blog articles
                return markdownIndex
                    .filter { it.route.startsWith("/blog") }
                    .map { it.toArticle() }
            }

            /**
             * Returns a list of portfolio articles.
             * 
             * This function filters the auto-generated markdownIndex list for articles with routes
             * that start with "/portfolio" and are posted, then converts them to Article objects.
             * 
             * The list is automatically updated when new markdown files are added to the portfolio directory.
             */
            fun getPortfolioArticles(): List<Article> {
                // Use the auto-generated markdownIndex list to get posted portfolio articles
                return markdownIndex
                    .filter { it.route.startsWith("/portfolio") }
                    .map { it.toArticle() }
            }
            """.trimIndent()

            // 3. Generate article descriptors
            val descriptorBlocks = publishedEntries.map { entry ->
                // Files are already in public/markdown, extract relative path
                val relPath = entry.filePath.substringAfter("resources/public/markdown/")

                val fm = entry.frontMatter

                // Get values directly from frontmatter
                val titleValue = fm["title"]?.firstOrNull()
                val descValue = fm["description"]?.firstOrNull()
                val dateValue = fm["date"]?.firstOrNull()
                val thumbValue = fm["thumbnailUrl"]?.firstOrNull()
                val tagsValue = fm["tags"]?.joinToString(", ") { "\"" + it + "\"" } ?: ""

                val titleStr = if (titleValue != null) "\"" + titleValue + "\"" else "null"
                val descStr = if (descValue != null) "\"" + descValue + "\"" else "null"
                val dateStr = if (dateValue != null) "\"" + dateValue + "\"" else "null"
                val thumbStr = if (thumbValue != null) "\"" + thumbValue + "\"" else "null"

                "ArticleDescriptor(\n" +
                        "    route = \"" + entry.route + "\",\n" +
                        "    filePath = \"/markdown/" + relPath.replace("\\", "/") + "\",\n" +
                        "    title = " + titleStr + ",\n" +
                        "    description = " + descStr + ",\n" +
                        "    date = " + dateStr + ",\n" +
                        "    tags = listOf(" + tagsValue + "),\n" +
                        "    thumbnail = " + thumbStr + "\n" +
                        ")"
            }

            // 4. Generate MarkdownIndex.kt (for backward compatibility)
            val indexContent = """
                // AUTO-GENERATED ‚Äì DO NOT EDIT
                package com.shevapro.website.generated

                data class ArticleDescriptor(
                    val route: String,
                    val filePath: String,
                    val title: String?,
                    val description: String?,
                    val date: String?,
                    val tags: List<String>,
                    val thumbnail: String?
                )

                val MarkdownIndex: List<ArticleDescriptor> = listOf(
                    ${descriptorBlocks.joinToString(",\n")}
                )
            """.trimIndent()

            genDir.resolve("MarkdownIndex.kt").writeText(indexContent)
            
            // 5. Generate MarkdownArticles.kt by replacing the placeholder with actual descriptors
            val markdownArticlesContent = templateContent.replace(
                "// ARTICLE_DESCRIPTORS_PLACEHOLDER", 
                descriptorBlocks.joinToString(",\n    ")
            )
            
            // 6. Write the generated file to the source directory
            srcDir.resolve("MarkdownArticles.kt").writeText(markdownArticlesContent)

            // 7. Update sitemap.xml with posted articles
            val sitemapFile = project.layout.projectDirectory.file("src/jsMain/resources/public/sitemap.xml").asFile
            val currentTimestamp = ZonedDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss'Z'"))

            if (sitemapFile.exists()) {
                println("üìÑ Updating sitemap.xml with ${publishedEntries.size} markdown entries...")

                // Read existing sitemap
                val existingSitemap = sitemapFile.readText()

                // Find the closing </urlset> tag and extract the base content
                val closingTagIndex = existingSitemap.lastIndexOf("</urlset>")
                if (closingTagIndex != -1) {
                    val baseSitemap = existingSitemap.substring(0, closingTagIndex).trim()

                    // Remove any existing blog/portfolio sections
                    val cleanedSitemap = baseSitemap
                        .replace(
                            Regex(
                                "\\s*<!-- Blog Posts -->.*?(?=\\s*<url>|\\s*<!-- Portfolio Items -->|$)",
                                RegexOption.DOT_MATCHES_ALL
                            ), ""
                        )
                        .replace(
                            Regex("\\s*<!-- Portfolio Items -->.*?(?=\\s*<url>|$)", RegexOption.DOT_MATCHES_ALL),
                            ""
                        )
                        .replace(
                            Regex(
                                "\\s*<url>\\s*<loc>https://www\\.shevapro\\.com/blog/.*?</url>",
                                RegexOption.DOT_MATCHES_ALL
                            ), ""
                        )
                        .replace(
                            Regex(
                                "\\s*<url>\\s*<loc>https://www\\.shevapro\\.com/portfolio/.*?</url>",
                                RegexOption.DOT_MATCHES_ALL
                            ), ""
                        )

                    // Update timestamps in existing URLs
                    val updatedBaseSitemap = cleanedSitemap.replace(
                        Regex("<lastmod>.*?</lastmod>"),
                        "<lastmod>$currentTimestamp</lastmod>"
                    )

                    val sitemapBuilder = StringBuilder(updatedBaseSitemap)

                    // All entries are already published - no need to filter again
                    val postedEntries = publishedEntries

                    // Add blog posts
                    val blogEntries = postedEntries.filter { it.route.startsWith("/blog") }
                    if (blogEntries.isNotEmpty()) {
                        sitemapBuilder.append("\n    <!-- Blog Posts -->")
                        blogEntries.forEach { entry ->
                            sitemapBuilder.append(
                                """
    <url>
        <loc>https://www.shevapro.com${entry.route}</loc>
        <changefreq>yearly</changefreq>
        <lastmod>$currentTimestamp</lastmod>
    </url>"""
                            )
                        }
                    }

                    // Add portfolio items
                    val portfolioEntries = postedEntries.filter { it.route.startsWith("/portfolio") }
                    if (portfolioEntries.isNotEmpty()) {
                        sitemapBuilder.append("\n    <!-- Portfolio Items -->")
                        portfolioEntries.forEach { entry ->
                            sitemapBuilder.append(
                                """
    <url>
        <loc>https://www.shevapro.com${entry.route}</loc>
        <changefreq>yearly</changefreq>
        <lastmod>$currentTimestamp</lastmod>
    </url>"""
                            )
                        }
                    }

                    sitemapBuilder.append("\n</urlset>")

                    // Write updated sitemap
                    sitemapFile.writeText(sitemapBuilder.toString())

                    val totalUrls = sitemapBuilder.toString().split("<url>").size - 1
                    val postedBlogCount = blogEntries.size
                    val postedPortfolioCount = portfolioEntries.size

                    println("‚úÖ Sitemap updated successfully:")
                    println("   üìù Blog posts: $postedBlogCount")
                    println("   üíº Portfolio items: $postedPortfolioCount")
                    println("   üîó Total URLs: $totalUrls")
                    println("   üïê Timestamp: $currentTimestamp")
                } else {
                    println("‚ö†Ô∏è Could not find closing </urlset> tag in existing sitemap")
                }
            } else {
                println("‚ö†Ô∏è Sitemap file does not exist at ${sitemapFile.absolutePath}")
            }
        }
    }
}

//// Make kobweb tasks depend on sitemap generation
//tasks.named("kobwebStart").configure {
//    // dependsOn("kobwebxMarkdownProcess") // TODO: Determine correct task name
//}

tasks.named("kobwebExport").configure {
    // Remove dependency for now until we determine the correct task name
    // dependsOn("kobwebxMarkdownProcess") // TODO: Determine correct task name
    finalizedBy("copy404")
}

tasks.register<Copy>("copy404") {
    // Adjust the path if your export location is different
    from("$rootDir/site/.kobweb/site/not-found.html")
    into("$rootDir/site/.kobweb/site")
    rename("not-found.html", "404.html")
    println("404.html has been copied successfully.")
}

kotlin {
    configAsKobwebApplication("website")
    setupTailwindProject()

    sourceSets {
        jsMain.dependencies {
            implementation(libs.compose.runtime)
            implementation(libs.compose.html.core)
            implementation(libs.kobweb.core)
            implementation(libs.kobweb.silk)
            implementation(libs.silk.icons.fa)
            implementation(libs.kobwebx.markdown)
            implementation(libs.kotlinx.serialization.json)

            implementation(npm("unified", "11.0.4"))
            implementation(npm("remark-parse", "11.0.0"))
            implementation(npm("remark-gfm", "4.0.0"))
            implementation(npm("remark-rehype", "11.1.0"))
            implementation(npm("rehype-raw", "7.0.0"))
            implementation(npm("rehype-stringify", "9.0.4"))

            implementation(project(":worker"))
        }
    }
    // Add generated markdown source directory to jsMain
    sourceSets["jsMain"].kotlin.srcDir(layout.buildDirectory.asFile.get().resolve("generated/kobweb/markdown"))
}
