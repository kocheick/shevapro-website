import com.varabyte.kobweb.gradle.application.util.configAsKobwebApplication
import kizzy.tailwind.utils.setupTailwindProject
import java.time.ZonedDateTime
import java.time.format.DateTimeFormatter

buildscript {
    dependencies {
        classpath("org.yaml:snakeyaml:2.0")
    }
}

plugins {
    alias(libs.plugins.kotlin.multiplatform)
    alias(libs.plugins.compose.compiler)
    alias(libs.plugins.kobweb.application)
    alias(libs.plugins.kobwebx.markdown)
    alias(libs.plugins.kotlin.serialization)
    id("io.github.dead8309.tailwind-kt").version("0.0.4")
}

group = "com.shevapro.website"
version = "1.0-SNAPSHOT"

// Markdown processing functions
fun generateArticleDescriptors(publishedEntries: List<Any>): List<String> {
    return publishedEntries.map { entry ->
        val entryClass = entry.javaClass
        val getFilePath = entryClass.getMethod("getFilePath")
        val getRoute = entryClass.getMethod("getRoute")
        val getFrontMatter = entryClass.getMethod("getFrontMatter")

        val filePath = getFilePath.invoke(entry) as String
        val route = getRoute.invoke(entry) as String
        val frontMatter = getFrontMatter.invoke(entry)

        val relPath = filePath.substringAfter("resources/public/markdown/")

        // Access frontMatter properties using array access syntax
        val frontMatterClass = frontMatter.javaClass
        val getMethod = frontMatterClass.getMethod("get", String::class.java)

        val titleValue = (getMethod.invoke(frontMatter, "title") as? List<*>)?.firstOrNull()?.toString()
        val descValue = (getMethod.invoke(frontMatter, "description") as? List<*>)?.firstOrNull()?.toString()
        val dateValue = (getMethod.invoke(frontMatter, "date") as? List<*>)?.firstOrNull()?.toString()
        val thumbValue = (getMethod.invoke(frontMatter, "thumbnailUrl") as? List<*>)?.firstOrNull()?.toString()
        val tagsValue = (getMethod.invoke(frontMatter, "tags") as? List<*>)?.joinToString(", ") { "\"$it\"" } ?: ""

        val titleStr = if (titleValue != null) "\"$titleValue\"" else "null"
        val descStr = if (descValue != null) "\"$descValue\"" else "null"
        val dateStr = if (dateValue != null) "\"$dateValue\"" else "null"
        val thumbStr = if (thumbValue != null) "\"$thumbValue\"" else "null"

        """ArticleDescriptor(
    route = "$route",
    filePath = "/markdown/${relPath.replace("\\", "/")}",
    title = $titleStr,
    description = $descStr,
    date = $dateStr,
    tags = listOf($tagsValue),
    thumbnail = $thumbStr
)"""
    }
}

fun getMarkdownArticlesTemplate(): String {
    return """
package com.shevapro.website.utils

import com.shevapro.website.models.Article

/**
 * IMPORTANT: Automated Markdown Article System
 * 
 * The build system automatically processes markdown files from:
 * - src/jsMain/resources/public/markdown/blog/
 * - src/jsMain/resources/public/markdown/portfolio/
 * 
 * It generates this file (MarkdownArticles.kt) with article metadata during the build process.
 * 
 * Current Implementation:
 * - This file is automatically generated during the build process
 * - It contains a list of all articles found in the markdown directories
 * - The functions getBlogArticles() and getPortfolioArticles() filter this list
 * - This approach ensures that the code compiles and works correctly
 * 
 * To add a new article:
 * 1. Add a new markdown file to the appropriate directory
 * 2. Build the project to regenerate this file with the updated article list
 * 
 * The system is now fully automated - no need to manually update article lists!
 */
data class ArticleDescriptor(
    val route: String,
    val filePath: String,
    val title: String?,
    val description: String?,
    val date: String?,
    val tags: List<String>,
    val thumbnail: String?
)

// Auto-generated list of articles from markdown files
private val markdownIndex = listOf(
    // ARTICLE_DESCRIPTORS_PLACEHOLDER
)

fun ArticleDescriptor.toArticle(): Article {
    val slug = route.substringAfterLast("/")
    val isPortfolioArticle = route.startsWith("/portfolio")

    return Article(
        id = slug,
        slug = slug,
        title = title ?: "Untitled",
        content = "", // Content will be loaded separately when needed
        description = description ?: "",
        author = "Shevapro",
        dateAdded = date ?: "",
        tags = tags,
        imageUrl = if (thumbnail != null) "/assets/images/${'$'}thumbnail" else "/favicon.ico",
        isPortfolioArticle = isPortfolioArticle,
        posted = true // All entries in the index are published
    )
}

/**
 * Returns a list of blog articles.
 * 
 * This function filters the auto-generated markdownIndex list for articles with routes
 * that start with "/blog" and are posted, then converts them to Article objects.
 * 
 * The list is automatically updated when new markdown files are added to the blog directory.
 */
fun getBlogArticles(): List<Article> {
    // Use the auto-generated markdownIndex list to get posted blog articles
    return markdownIndex
        .filter { it.route.startsWith("/blog") }
        .map { it.toArticle() }
}

/**
 * Returns a list of portfolio articles.
 * 
 * This function filters the auto-generated markdownIndex list for articles with routes
 * that start with "/portfolio" and are posted, then converts them to Article objects.
 * 
 * The list is automatically updated when new markdown files are added to the portfolio directory.
 */
fun getPortfolioArticles(): List<Article> {
    // Use the auto-generated markdownIndex list to get posted portfolio articles
    return markdownIndex
        .filter { it.route.startsWith("/portfolio") }
        .map { it.toArticle() }
}
""".trimIndent()
}

fun generateMarkdownFiles(
    project: org.gradle.api.Project,
    descriptorBlocks: List<String>
) {
    val genDir = project.layout.buildDirectory.asFile.get().resolve("generated/kobweb/markdown")
    genDir.mkdirs()

    val srcDir = project.layout.projectDirectory.asFile.resolve("src/jsMain/kotlin/com/shevapro/website/utils")

    // Generate MarkdownIndex.kt (for backward compatibility)
    val indexContent = """
// AUTO-GENERATED ‚Äì DO NOT EDIT
package com.shevapro.website.generated

data class ArticleDescriptor(
    val route: String,
    val filePath: String,
    val title: String?,
    val description: String?,
    val date: String?,
    val tags: List<String>,
    val thumbnail: String?
)

val MarkdownIndex: List<ArticleDescriptor> = listOf(
    ${descriptorBlocks.joinToString(",\n")}
)
""".trimIndent()

    genDir.resolve("MarkdownIndex.kt").writeText(indexContent)

    // Generate MarkdownArticles.kt
    val markdownArticlesContent = getMarkdownArticlesTemplate().replace(
        "// ARTICLE_DESCRIPTORS_PLACEHOLDER",
        descriptorBlocks.joinToString(",\n    ")
    )

    srcDir.resolve("MarkdownArticles.kt").writeText(markdownArticlesContent)
}

fun updateSitemap(project: org.gradle.api.Project, publishedEntries: List<Any>) {
    val sitemapFile = project.layout.projectDirectory.file("src/jsMain/resources/public/sitemap.xml").asFile
    val currentTimestamp = ZonedDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss'Z'"))

    if (!sitemapFile.exists()) {
        println("‚ö†Ô∏è Sitemap file does not exist at ${sitemapFile.absolutePath}")
        return
    }

    println("üìÑ Updating sitemap.xml with ${publishedEntries.size} markdown entries...")

    val existingSitemap = sitemapFile.readText()
    val closingTagIndex = existingSitemap.lastIndexOf("</urlset>")

    if (closingTagIndex == -1) {
        println("‚ö†Ô∏è Could not find closing </urlset> tag in existing sitemap")
        return
    }

    val baseSitemap = existingSitemap.substring(0, closingTagIndex).trim()

    // Remove existing blog/portfolio sections
    val cleanedSitemap = baseSitemap
        .replace(
            Regex(
                "\\s*<!-- Blog Posts -->.*?(?=\\s*<url>|\\s*<!-- Portfolio Items -->|$)",
                RegexOption.DOT_MATCHES_ALL
            ), ""
        )
        .replace(Regex("\\s*<!-- Portfolio Items -->.*?(?=\\s*<url>|$)", RegexOption.DOT_MATCHES_ALL), "")
        .replace(
            Regex("\\s*<url>\\s*<loc>https://www\\.shevapro\\.com/blog/.*?</url>", RegexOption.DOT_MATCHES_ALL),
            ""
        )
        .replace(
            Regex(
                "\\s*<url>\\s*<loc>https://www\\.shevapro\\.com/portfolio/.*?</url>",
                RegexOption.DOT_MATCHES_ALL
            ), ""
        )

    // Update timestamps in existing URLs
    val updatedBaseSitemap = cleanedSitemap.replace(
        Regex("<lastmod>.*?</lastmod>"),
        "<lastmod>$currentTimestamp</lastmod>"
    )

    val sitemapBuilder = StringBuilder(updatedBaseSitemap)

    // Add blog posts
    val blogEntries = publishedEntries.filter { entry ->
        val entryClass = entry.javaClass
        val getRoute = entryClass.getMethod("getRoute")
        val route = getRoute.invoke(entry) as String
        route.startsWith("/blog")
    }

    if (blogEntries.isNotEmpty()) {
        sitemapBuilder.append("\n    <!-- Blog Posts -->")
        blogEntries.forEach { entry ->
            val entryClass = entry.javaClass
            val getRoute = entryClass.getMethod("getRoute")
            val route = getRoute.invoke(entry) as String
            sitemapBuilder.append(
                """
    <url>
        <loc>https://www.shevapro.com$route</loc>
        <changefreq>yearly</changefreq>
        <lastmod>$currentTimestamp</lastmod>
    </url>"""
            )
        }
    }

    // Add portfolio items
    val portfolioEntries = publishedEntries.filter { entry ->
        val entryClass = entry.javaClass
        val getRoute = entryClass.getMethod("getRoute")
        val route = getRoute.invoke(entry) as String
        route.startsWith("/portfolio")
    }

    if (portfolioEntries.isNotEmpty()) {
        sitemapBuilder.append("\n    <!-- Portfolio Items -->")
        portfolioEntries.forEach { entry ->
            val entryClass = entry.javaClass
            val getRoute = entryClass.getMethod("getRoute")
            val route = getRoute.invoke(entry) as String
            sitemapBuilder.append(
                """
    <url>
        <loc>https://www.shevapro.com$route</loc>
        <changefreq>yearly</changefreq>
        <lastmod>$currentTimestamp</lastmod>
    </url>"""
            )
        }
    }

    sitemapBuilder.append("\n</urlset>")
    sitemapFile.writeText(sitemapBuilder.toString())

    val totalUrls = sitemapBuilder.toString().split("<url>").size - 1
    println("‚úÖ Sitemap updated successfully:")
    println("   üìù Blog posts: ${blogEntries.size}")
    println("   üíº Portfolio items: ${portfolioEntries.size}")
    println("   üîó Total URLs: $totalUrls")
    println("   üïê Timestamp: $currentTimestamp")
}

kobweb {
    app {
        index {
            // Set site-wide description for SEO
            description.set("Shevapro's personal website showcasing portfolio, blog, and services")
            
            // Note: Other site-wide SEO metadata is handled in the Layout component
            // through the setPageMetadata function
        }
    }
    markdown {
        // Tell Kobweb to look for markdown files in the public directory
        addSource(project.layout.projectDirectory.dir("src/jsMain/resources/public/markdown"))

        /**
         * 1. Files are already in `src/jsMain/resources/public/markdown/...` for runtime HTTP access
         * 2. Generate a Kotlin source file (`MarkdownIndex.kt`) that lists metadata for all posts.
         */
        process.set { entries ->
            // Filter out unpublished entries at the very beginning
            val publishedEntries = entries.filter { entry ->
                val getFrontMatter = entry.javaClass.getMethod("getFrontMatter")
                val frontMatter = getFrontMatter.invoke(entry)
                val frontMatterClass = frontMatter.javaClass
                val getMethod = frontMatterClass.getMethod("get", String::class.java)
                val postedValue =
                    (getMethod.invoke(frontMatter, "posted") as? List<*>)?.firstOrNull()?.toString()?.toBoolean()
                        ?: true
                postedValue
            }

            println("üìÑ Processing markdown files:")
            println("   üìù Total found: ${entries.size}")
            println("   ‚úÖ Published: ${publishedEntries.size}")
            println("   üö´ Unpublished (skipped): ${entries.size - publishedEntries.size}")

            // Generate article descriptors
            val descriptorBlocks = generateArticleDescriptors(publishedEntries)

            // Generate markdown files
            generateMarkdownFiles(project, descriptorBlocks)

            // Update sitemap
            updateSitemap(project, publishedEntries)
        }
    }
}

// Make kobweb tasks depend on sitemap generation
//tasks.named("kobwebStart").configure {
//    // dependsOn("kobwebxMarkdownProcess") // TODO: Determine correct task name
//}

tasks.named("kobwebExport").configure {
    // Remove dependency for now until we determine the correct task name
    // dependsOn("kobwebxMarkdownProcess") // TODO: Determine correct task name
    finalizedBy("copy404")
}

tasks.register<Copy>("copy404") {
    // Adjust the path if your export location is different
    from("$rootDir/site/.kobweb/site/not-found.html")
    into("$rootDir/site/.kobweb/site")
    rename("not-found.html", "404.html")
    println("404.html has been copied successfully.")
}

kotlin {
    configAsKobwebApplication("website")
    setupTailwindProject()

    sourceSets {
        jsMain.dependencies {
            implementation(libs.compose.runtime)
            implementation(libs.compose.html.core)
            implementation(libs.kobweb.core)
            implementation(libs.kobweb.silk)
            implementation(libs.silk.icons.fa)
            implementation(libs.kobwebx.markdown)
            implementation(libs.kotlinx.serialization.json)

            implementation(npm("unified", "11.0.4"))
            implementation(npm("remark-parse", "11.0.0"))
            implementation(npm("remark-gfm", "4.0.0"))
            implementation(npm("remark-rehype", "11.1.0"))
            implementation(npm("rehype-raw", "7.0.0"))
            implementation(npm("rehype-stringify", "9.0.4"))

            implementation(project(":worker"))
        }
    }
    // Add generated markdown source directory to jsMain
    sourceSets["jsMain"].kotlin.srcDir(layout.buildDirectory.asFile.get().resolve("generated/kobweb/markdown"))
}
